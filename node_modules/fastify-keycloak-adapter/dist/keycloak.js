"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cookie_1 = __importDefault(require("@fastify/cookie"));
const jwt_1 = __importDefault(require("@fastify/jwt"));
const session_1 = __importDefault(require("@fastify/session"));
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importDefault(require("axios-retry"));
const fastify_plugin_1 = __importDefault(require("fastify-plugin"));
const B = __importStar(require("fp-ts/boolean"));
const E = __importStar(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const O = __importStar(require("fp-ts/Option"));
const TE = __importStar(require("fp-ts/TaskEither"));
const grant_1 = __importDefault(require("grant"));
const t = __importStar(require("io-ts"));
const qs_1 = __importDefault(require("qs"));
const wildcard_match_1 = __importDefault(require("wildcard-match"));
let tokenEndpoint = '';
const AppOriginCodec = new t.Type('AppOrigin', (input) => typeof input === 'string', (input, context) => typeof input === 'string' &&
    (input.startsWith('http://') || input.startsWith('https://')) &&
    input.endsWith('/') === false
    ? t.success(input)
    : t.failure(input, context), t.identity);
const KeycloakSubdomainCodec = new t.Type('KeycloakSubdomain', (input) => typeof input === 'string', (input, context) => typeof input === 'string' &&
    input.length > 0 &&
    input.startsWith('http://') === false &&
    input.startsWith('https://') === false &&
    input.endsWith('/') === false
    ? t.success(input)
    : t.failure(input, context), t.identity);
const requiredOptions = t.type({
    appOrigin: t.readonly(AppOriginCodec),
    keycloakSubdomain: t.readonly(KeycloakSubdomainCodec),
    clientId: t.readonly(t.string),
    clientSecret: t.readonly(t.string)
});
const partialOptions = t.partial({
    useHttps: t.readonly(t.boolean),
    logoutEndpoint: t.readonly(t.string),
    excludedPatterns: t.readonly(t.array(t.string)),
    scope: t.array(t.readonly(t.string)),
    callback: t.readonly(t.string),
    disableCookiePlugin: t.readonly(t.boolean),
    disableSessionPlugin: t.readonly(t.boolean),
    retries: t.readonly(t.number),
    autoRefreshToken: t.readonly(t.boolean)
});
const KeycloakOptions = t.intersection([requiredOptions, partialOptions]);
const getWellKnownConfiguration = (url) => TE.tryCatch(() => axios_1.default.get(url), (e) => e);
const validAppOrigin = (opts) => (0, function_1.pipe)(opts.appOrigin, AppOriginCodec.decode, E.match(() => E.left(new Error(`Invalid appOrigin: ${opts.appOrigin}`)), () => E.right(opts)));
const validKeycloakSubdomain = (opts) => (0, function_1.pipe)(opts.keycloakSubdomain, KeycloakSubdomainCodec.decode, E.match(() => E.left(new Error(`Invalid keycloakSubdomain: ${opts.keycloakSubdomain}`)), () => E.right(opts)));
exports.default = (0, fastify_plugin_1.default)((fastify, opts) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    (0, axios_retry_1.default)(axios_1.default, {
        retries: opts.retries ? opts.retries : 3,
        retryDelay: axios_retry_1.default.exponentialDelay,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onRetry: (retryCount, error, _requestConfig) => {
            fastify.log.error(`Retry #${retryCount} ${error.message}`);
        }
    });
    (0, function_1.pipe)(opts, validAppOrigin, E.chain(validKeycloakSubdomain), E.match((e) => {
        fastify.log.error(`${e}`);
        throw new Error(e.message);
    }, () => {
        fastify.log.debug(`Keycloak Options valid successfully. Keycloak options: ${JSON.stringify(opts)}`);
    }));
    const protocol = opts.useHttps ? 'https://' : 'http://';
    const keycloakConfiguration = yield (0, function_1.pipe)(`${protocol}${opts.keycloakSubdomain}/.well-known/openid-configuration`, getWellKnownConfiguration, TE.map((response) => response.data))();
    function registerDependentPlugin(config) {
        var _a, _b;
        if (!opts.disableCookiePlugin) {
            fastify.register(cookie_1.default);
        }
        if (!opts.disableSessionPlugin) {
            fastify.register(session_1.default, {
                secret: new Array(32).fill('a').join(''),
                cookie: { secure: false }
            });
        }
        tokenEndpoint = config.token_endpoint;
        fastify.register(grant_1.default.fastify()({
            defaults: {
                origin: opts.appOrigin,
                transport: 'session'
            },
            keycloak: {
                key: opts.clientId,
                secret: opts.clientSecret,
                oauth: 2,
                authorize_url: config.authorization_endpoint,
                access_url: config.token_endpoint,
                callback: (_a = opts.callback) !== null && _a !== void 0 ? _a : '/',
                scope: (_b = opts.scope) !== null && _b !== void 0 ? _b : ['openid'],
                nonce: true
            }
        }));
    }
    (0, function_1.pipe)(keycloakConfiguration, E.match((error) => {
        throw new Error(`Failed to get openid-configuration: ${JSON.stringify(error.toJSON())}`);
    }, (config) => {
        registerDependentPlugin(config);
    }));
    const getRealmResponse = (url) => TE.tryCatch(() => axios_1.default.get(url), (e) => new Error(`${e}`));
    const secretPublicKey = yield (0, function_1.pipe)(`${protocol}${opts.keycloakSubdomain}`, getRealmResponse, TE.map((response) => response.data), TE.map((realmResponse) => realmResponse.public_key), TE.map((publicKey) => `-----BEGIN PUBLIC KEY-----\n${publicKey}\n-----END PUBLIC KEY-----`))();
    (0, function_1.pipe)(secretPublicKey, E.match((e) => {
        fastify.log.fatal(`Failed to get public key: ${e}`);
        throw new Error(`Failed to get public key: ${e}`);
    }, (publicKey) => {
        fastify.register(jwt_1.default, {
            secret: {
                private: 'dummyPrivate',
                public: publicKey
            },
            verify: { algorithms: ['RS256'] }
        });
    }));
    const getGrantFromSession = (request) => (0, function_1.pipe)(request.session.grant, O.fromNullable, O.match(() => E.left(new Error(`grant not found in session`)), () => E.right(request.session.grant)));
    const getResponseFromGrant = (grant) => (0, function_1.pipe)(grant.response, O.fromNullable, E.fromOption(() => new Error(`response not found in grant`)));
    const getIdTokenFromResponse = (response) => (0, function_1.pipe)(response.id_token, O.fromNullable, E.fromOption(() => new Error(`id_token not found in response with response: ${response}`)));
    const verifyIdToken = (idToken) => E.tryCatch(() => fastify.jwt.verify(idToken), (e) => new Error(`Failed to verify id_token: ${e.message}`));
    const decodedTokenToJson = (decodedToken) => E.tryCatch(() => JSON.parse(JSON.stringify(decodedToken)), (e) => new Error(`Failed to parsing json from decodedToken: ${e}`));
    const authentication = (request) => (0, function_1.pipe)(getGrantFromSession(request), E.chain(getResponseFromGrant), E.chain(getIdTokenFromResponse), E.chain(verifyIdToken), E.chain(decodedTokenToJson));
    const getBearerTokenFromRequest = (request) => (0, function_1.pipe)(request.headers.authorization, O.fromNullable, O.map((str) => str.substring(7)));
    const getRefreshToken = (request) => {
        var _a;
        const refresh_token = (_a = request.session.grant.response) === null || _a === void 0 ? void 0 : _a.refresh_token;
        const postData = qs_1.default.stringify({
            client_id: opts.clientId,
            client_secret: opts.clientSecret,
            grant_type: 'refresh_token',
            refresh_token
        });
        return axios_1.default.post(tokenEndpoint, postData);
    };
    const verifyJwtToken = (token) => E.tryCatch(() => fastify.jwt.verify(token), (e) => new Error(`Failed to verify token: ${e.message}`));
    const grantRoutes = ['/connect/:provider', '/connect/:provider/:override'];
    const isGrantRoute = (request) => grantRoutes.includes(request.routeOptions.url);
    const userPayloadMapper = (0, function_1.pipe)(opts.userPayloadMapper, O.fromNullable, O.match(() => (tokenPayload) => ({
        account: tokenPayload.preferred_username,
        name: tokenPayload.name
    }), (a) => a));
    function updateToken(request, done) {
        getRefreshToken(request)
            .then((response) => response.data)
            .then((response) => {
            request.session.grant.response.refresh_token = response.refresh_token;
            request.session.grant.response.access_token = response.access_token;
            request.session.grant.response.id_token = response.id_token;
            request.log.debug('Keycloak adapter: Refresh token done.');
            done();
        })
            .catch((error) => {
            request.log.error(`Failed to refresh token: ${error}`);
            done();
        });
    }
    function authenticationErrorHandler(e, request, reply, done) {
        request.log.debug(`Keycloak adapter: ${e.message}`);
        if (opts.autoRefreshToken && e.message.includes('The token has expired')) {
            request.log.debug('Keycloak adapter: The token has expired, refreshing token ...');
            updateToken(request, done);
        }
        else {
            if (request.method === 'GET' && !opts.unauthorizedHandler) {
                reply.redirect(`${opts.appOrigin}/connect/keycloak`);
            }
            else {
                unauthorizedHandler(request, reply);
            }
        }
    }
    function authenticationByGrant(request, reply, done) {
        (0, function_1.pipe)(authentication(request), E.fold((e) => {
            authenticationErrorHandler(e, request, reply, done);
        }, (decodedJson) => {
            request.session.user = userPayloadMapper(decodedJson);
            request.log.debug(`${JSON.stringify(request.session.user)}`);
            done();
        }));
    }
    const unauthorizedHandler = (0, function_1.pipe)(opts.unauthorizedHandler, O.fromNullable, O.match(() => (_request, reply) => {
        reply.status(401).send(`Unauthorized`);
    }, (a) => a));
    function authenticationByToken(request, reply, bearerToken, done) {
        (0, function_1.pipe)(bearerToken, verifyJwtToken, E.chain(decodedTokenToJson), E.fold((e) => {
            request.log.debug(`Keycloak adapter: ${e.message}`);
            unauthorizedHandler(request, reply);
            done();
        }, (decodedJson) => {
            request.session.user = userPayloadMapper(decodedJson);
            request.log.debug(`${JSON.stringify(request.session.user)}`);
            done();
        }));
    }
    const matchers = (0, function_1.pipe)((_a = opts.excludedPatterns) === null || _a === void 0 ? void 0 : _a.map((pattern) => (0, wildcard_match_1.default)(pattern)), O.fromNullable);
    const filterExcludedPattern = (request) => (0, function_1.pipe)(matchers, O.map((matchers) => matchers.filter((matcher) => matcher(request.url))), O.map((matchers) => matchers.length > 0), O.match(() => O.of(request), (b) => (0, function_1.pipe)(b, B.match(() => O.of(request), () => O.none))));
    const filterGrantRoute = (request) => (0, function_1.pipe)(request, O.fromPredicate((request) => !isGrantRoute(request)));
    fastify.addHook('preValidation', (request, reply, done) => {
        (0, function_1.pipe)(request, filterGrantRoute, O.chain(filterExcludedPattern), O.match(() => {
            done();
        }, (request) => (0, function_1.pipe)(request, getBearerTokenFromRequest, O.match(() => authenticationByGrant(request, reply, done), (bearerToken) => authenticationByToken(request, reply, bearerToken, done)))));
    });
    function logout(request, reply) {
        request.session.destroy((error) => {
            (0, function_1.pipe)(error, O.fromNullable, O.match(() => {
                (0, function_1.pipe)(keycloakConfiguration, E.map((config) => reply.redirect(`${config.end_session_endpoint}?redirect_uri=${opts.appOrigin}`)));
            }, (e) => {
                request.log.error(`Failed to logout: ${e}`);
                reply.status(500).send({ msg: `Internal Server Error: ${e}` });
            }));
        });
    }
    const logoutEndpoint = (_b = opts.logoutEndpoint) !== null && _b !== void 0 ? _b : '/logout';
    fastify.get(logoutEndpoint, (request, reply) => __awaiter(void 0, void 0, void 0, function* () {
        (0, function_1.pipe)(request.session.user, O.fromNullable, O.match(() => {
            reply.redirect('/');
        }, () => {
            logout(request, reply);
        }));
    }));
    fastify.log.info(`Keycloak registered successfully!`);
}));
